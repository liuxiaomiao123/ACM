/*三种思路：

1. N张字条的所有可能排列自然是N!（分母）。
现在的问题就是求N张字条的错排数f(N)（分子）。
首先我们考虑，如果前面N-1个人拿的都不是自己的票，即前N-1个人满足错排，现在又来了一个人，他手里拿的是自己的票。只要他把自己的票与其他N-1个人中的任意一个交换，就可以满足N个人的错排。这时有(N-1)*f(N-1)种方法。

Besides，我们考虑，如果前N-1个人不满足错排，而第N个人把自己的票与其中一个人交换后恰好满足错排。
这种情况发生在原先N-1人中，N-2个人满足错排，有且仅有一个人拿的是自己的票，而第N个人恰好与他做了交换，这时候就满足了错排。
又因为前N-1个人中，每个人都有机会拿着自己的票。所以有N-1种交换的可能。故这时有(N-1)*f(N-2)种方法。

综上所述：f(N)=(N-1)*[f(N-1)+f(N-2)] 

2. 另一种推导思路是先通过容斥定理直接计算出错排数f(n)=n!(1/2!-1/3!+…..+((-1)^n)/n!)

所以f(n)/n!-f(n-1)/(n-1)!=((-1)^n)/n!

两边同时乘上n!有f(n)-n*f(n-1)=(-1)^n

所以f(n-1)-(n-1)*f(n-2)=(-1)^(n-1)=(-1)*[f(n)-n*f(n-1)]

化简得f(n)=(n-1)*[f(n-1)+f(n-2)] */

#include <stdio.h>
#define M 25


int main()
{
	int c,n,i;
	double factorial;
	_int64 a[M];
	a[1]=0;
	a[2]=1;
	for(i=3;i<M;i++)
	{
		a[i]=(i-1)*(a[i-1]+a[i-2]);
	}
	while(scanf("%d",&c) !=EOF )
	 {
	 	while(c--)
	 	{
	 		scanf("%d",&n);
	 		factorial=1.0;
	 		for(i=1;i<=n;i++)
	 		    factorial*=i;
	 		printf("%.2lf%%\n",a[n]/factorial*100); 
		 }
	 }
	return 0;
}
